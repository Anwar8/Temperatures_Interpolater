import numpy as np

def regularise_data(regular_x, list_of_np_arrays):
    """
    Given an array of NumPy arrays each consisting of x and y, and an array containing
    regular x values, this function will use linear interpolation to generate a NumPy
    array with the regular x and corresponding y arrays generated by linear interpolation.
    :param regular_x: x values for which we want to generate y values
    :type: a NumPy array of floats or integers
    :param list_of_np_arrays: a python list containg NumPy arrays each of which contain x and y data
    :type: list of NumPy nD arrays
    :return regularised_data: the regular x data and corresponding y data
    :rtype: NumPy nD array of integers or floats
    :raise TypeError if regular_x not an np.array, or if list_of_np_arrays is not a list of np.ndarrays.
    :raise ValueError if any of the np arrays in list_of_np_arrays do not contain 2 columns 
    """
    if not(isinstance(regular_x, np.ndarray)):
        raise TypeError("regular_x has to be of type np.array. It is currently {}".format(type(regular_x)))
    
    if not(isinstance(list_of_np_arrays, list)):
         raise TypeError("array_of_np_arrays has to be of type `list`. It is currently {}".format(type(regular_x)))

    for data_array_index, a_np_data_array in enumerate(list_of_np_arrays):
        if not(isinstance(a_np_data_array, np.ndarray)):
            raise TypeError("""list_np_array has to be a list of type np.ndarray.
                    \nList item {} is currently {}""".format(type(data_array_index, a_np_data_array)))
        if (a_np_data_array.shape[1] != 2):
            raise ValueError("Each numpy array in array_of_np_arrays must have two columns. Array {} has {} columns.".format(data_array_index, a_np_data_array.shape[1]))

    number_of_np_arrays = len(list_of_np_arrays)
    number_of_regular_time_steps = len(regular_x)
    regularised_data_array = np.zeros((number_of_regular_time_steps, number_of_np_arrays + 1))
    regularised_data_array[:, 0] = regular_x 
    # Iterate over the list of np array passed to the function
    for data_array_index, a_np_data_array in enumerate(list_of_np_arrays):
        for x_from_regular_x_index, x_from_regular_x in enumerate(regular_x):
            if (x_from_regular_x_index == 0):
                # It is expected that the first time step in regular x has the same
                # value as the first time from the passed numpy array
                regularised_data_array[x_from_regular_x_index, data_array_index + 1] = a_np_data_array[x_from_regular_x_index,1]
            elif (x_from_regular_x_index == (number_of_regular_time_steps - 1)):
                if (np.any(np.isclose(a_np_data_array[:,0], x_from_regular_x, rtol=1e-5))):
                    first_corresponding_y = a_np_data_array[a_np_data_array[:,0] == x_from_regular_x, 1]
                    regularised_data_array[x_from_regular_x_index, data_array_index+1] = first_corresponding_y
                else:
                    # If no corresponding x is found in the series, then the last
                    # point is assumed to correspond directly to the last point from
                    # the passed numpy array
                    regularised_data_array[x_from_regular_x_index, data_array_index+1] = a_np_data_array[-1,1]    
                
            else:
                for index_within_data_array, x_from_data_array in enumerate(a_np_data_array[:,0]):
                    # find where the regularised x point lies within the given numpy
                    # array, interpolate, and fill the result array
                    if (x_from_regular_x < x_from_data_array):
                        regularised_data_array[x_from_regular_x_index, data_array_index + 1] = linearly_interpolate(
                            x_from_regular_x, a_np_data_array[index_within_data_array - 1, 0], x_from_data_array,
                            a_np_data_array[index_within_data_array - 1, 1],
                            a_np_data_array[index_within_data_array, 1])
                        break
                                                      
    return regularised_data_array

def linearly_interpolate(x, x_i, x_f, y_i, y_f):
    """
    Performs a linear interpolation between two points.
    :param x: x value at the intermediate point for which we are interpolating.
    :type: float or int
    :param x_i: x value at the initial point
    :type: float or int
    :param x_f: x value at the final point
    :type: float or int
    :param y_i: y value at the initial point
    :type: float or int
    :param y_f: y value at the final point
    :type: float or int
    :return y: the y value interpolated corresponding to the given intermediate x value
    :rtype: float or int
    :raise ValueError: if x not between x_i and x_f, and if x_i was larger than x_f
    """
    if (x_f < x_i):
        raise ValueError("x_f must be larger than x_i. given x_f = {} and is smaller than x_i = {}.".format(x_f, x_i))
    if (x > x_f) or (x < x_i):
        raise ValueError("x must lie between x_i and x_f. x = {}, while x_i = {} and x_f = {}".format(x, x_i, x_f))
    
    if np.isclose(x, x_i, rtol=1e-4):
        y = y_i
    elif np.isclose(x, x_f, rtol=1e-4):
        y = y_f
    else:
        y = y_i + (x - x_i)*(y_f - y_i)/(x_f - x_i)
    return y

def interpolate_between_columns(ordered_column_titles, columns, interpolation_array):
    """
    Given a numpy ndarray containing data pertaining to a particular value (say,
    distance), an array containing that value for each column, and an array containing
    the values for which new columns will be interpolated, the function returns a
    new array of columns with the same number of rows as the original columns but
    the same number of columns as the iterpolation arrray.
    :param ordered_column_titles: ordered values corresponding to each columns
    :type: a NumPy array of floats or integers
    :param columns: columns which provide the original data for interpolation
    :type: NumPy nD array
    :param interpolation_array: the new values for which the columns will be interpolated
    :type: NumPy nD array of integers or floats
    :return interpolated_columns: columns corresponding to the interpolation array
    :rtype: NumPy nd array of floats or ints
    :raise TypeError: if columns not a numpy nd array
    :raise ValueError: 
    """
    if not(isinstance(columns, np.ndarray)):
        raise TypeError("columns has to be of type np.ndarray. It is currently {}".format(type(columns)))
    if not(isinstance(ordered_column_titles, np.ndarray)):
        raise TypeError("ordered_column_titles has to be of type np.ndarray. It is currently {}".format(type(ordered_column_titles)))
    if not(isinstance(interpolation_array, np.ndarray)):
        raise TypeError("interpolation_array has to be of type np.ndarray. It is currently {}".format(type(interpolation_array)))
    
    # ensures that we can index the shape of the ordered column titles array
    # even if it's a 1D array.
    if ordered_column_titles.ndim == 1:
        ordered_column_titles = ordered_column_titles[np.newaxis,:]
    if interpolation_array.ndim == 1:
        interpolation_array = interpolation_array[np.newaxis,:]

    if ordered_column_titles.shape[1] != columns.shape[1]:
        raise ValueError("""there are {} columns, but {} titles.\n
            the ordered_column_titles and the columns arrays must 
            have the same number of columns""".format(columns.shape[1], ordered_column_titles.shape[1]))
    if ordered_column_titles.shape[0] != 1:
        raise ValueError("ordered_column_titles has {} rows. It should have exactly 1 row.".
            format(ordered_column_titles.shape[1]))
    if interpolation_array.shape[0] != 1:
        raise ValueError("interpolation_array has {} rows. It should have exactly 1 row.".
            format(interpolation_array.shape[1]))
    if np.any(ordered_column_titles != np.sort(ordered_column_titles)):
        raise ValueError("""ordered_column_titles have to be sorted in ascending order.\n
            They are currently ordered: {}\n
            but they should be ordered: {}""".format(ordered_column_titles, ordered_column_titles.sort()))
    
    if interpolation_array[:,0] < ordered_column_titles[:,0]:
        raise ValueError("""Cannot request interpolation point before
            the first given data point. \nFirst given data point = {}, 
            and first requested interpolation point = {}.
            """.format(ordered_column_titles[:,0], interpolation_array[:,0]))
    if ordered_column_titles[:,-1] < interpolation_array[:,-1]:
        raise ValueError("""Cannot request interpolation point after
            the last given data point. \Last given data point = {}, 
            and last requested interpolation point = {}.
            """.format(ordered_column_titles[:,-1], interpolation_array[:,-1]))

    # preallocate the right output size
    interpolated_columns = np.zeros((columns.shape[0], interpolation_array.shape[1]))
    
    for interpolated_column_i, target_interpolation_value in enumerate(interpolation_array[0,:]):
        for column_i, column_title in enumerate(ordered_column_titles[0,:]):
            if (target_interpolation_value < column_title):
                interpolated_columns[:,interpolated_column_i] = linearly_interpolate(
                    target_interpolation_value,
                    ordered_column_titles[0,column_i - 1], ordered_column_titles[0,column_i],
                    columns[:,column_i - 1], columns[:,column_i])
                break
            elif  np.isclose(target_interpolation_value, column_title, rtol=1e-4):
                interpolated_columns[:,interpolated_column_i] = linearly_interpolate(
                    target_interpolation_value,
                    ordered_column_titles[0,column_i], ordered_column_titles[0,column_i],
                    columns[:,column_i], columns[:,column_i])

    return interpolated_columns